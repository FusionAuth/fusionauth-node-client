/*
 * Copyright (c) 2018, FusionAuth, All Rights Reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

'use strict';

const RESTClient = require('./RESTClient.js');
require('promise');

const FusionAuthClient = function(apiKey, host) {
  this.apiKey = apiKey;
  this.host = host;
};

FusionAuthClient.constructor = FusionAuthClient;
//noinspection JSUnusedGlobalSymbols
FusionAuthClient.prototype = {

  /**
   * Takes an action on a user. The user being actioned is called the "actionee" and the user taking the action is called the
   * "actioner". Both user ids are required. You pass the actionee's user id into the method and the actioner's is put into the
   * request object.
   *
   * @param {string} actioneeUserId The actionee's user id.
   * @param {Object} request The action request that includes all of the information about the action being taken including
   *    the id of the action, any options and the duration (if applicable).
   * @return {Promise} A Promise for the FusionAuth call.
   */
  actionUser: function(actioneeUserId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlSegment(actioneeUserId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Cancels the user action.
   *
   * @param {string} actionId The action id of the action to cancel.
   * @param {Object} request The action request that contains the information about the cancellation.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  cancelAction: function(actionId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlSegment(actionId)
          .setJSONBody(request)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Changes a user's password using the change password Id. This usually occurs after an email has been sent to the user
   * and they clicked on a link to reset their password.
   *
   * @param {string} changePasswordId The change password Id used to find the user. This value is generated by FusionAuth once the change password workflow has been initiated.
   * @param {Object} request The change password request that contains all of the information used to change the password.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  changePassword: function(changePasswordId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/change-password')
          .urlSegment(changePasswordId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Changes a user's password using their identity (login id and password). Using a loginId instead of the verificationId
   * bypasses the email verification and allows a password to be changed directly without first calling the #forgotPassword
   * method.
   *
   * @param {Object} request The change password request that contains all of the information used to change the password.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  changePasswordByIdentity: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/change-password')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Adds a comment to the user's account.
   *
   * @param {Object} request The request object that contains all of the information used to create the user comment.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  commentOnUser: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/comment')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates an application. You can optionally specify an Id for the application, if not provided one will be generated.
   *
   * @param {?string} applicationId (Optional) The Id to use for the application. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the application.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createApplication: function(applicationId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a new role for an application. You must specify the id of the application you are creating the role for.
   * You can optionally specify an Id for the role inside the ApplicationRole object itself, if not provided one will be generated.
   *
   * @param {string} applicationId The Id of the application to create the role on.
   * @param {?string} roleId (Optional) The Id of the role. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the application role.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createApplicationRole: function(applicationId, roleId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlSegment("role")
          .urlSegment(roleId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates an audit log with the message and user name (usually an email). Audit logs should be written anytime you
   * make changes to the FusionAuth database. When using the FusionAuth Backend web interface, any changes are automatically
   * written to the audit log. However, if you are accessing the API, you must write the audit logs yourself.
   *
   * @param {Object} request The request object that contains all of the information used to create the audit log entry.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createAuditLog: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system/audit-log')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates an email template. You can optionally specify an Id for the template, if not provided one will be generated.
   *
   * @param {?string} emailTemplateId (Optional) The Id for the template. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the email template.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createEmailTemplate: function(emailTemplateId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template')
          .urlSegment(emailTemplateId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a group. You can optionally specify an Id for the group, if not provided one will be generated.
   *
   * @param {?string} groupId (Optional) The Id for the group. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the group.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createGroup: function(groupId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group')
          .urlSegment(groupId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a member in a group.
   *
   * @param {Object} request The request object that contains all of the information used to create the group member(s).
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createGroupMembers: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group/member')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates an identity provider. You can optionally specify an Id for the identity provider, if not provided one will be generated.
   *
   * @param {?string} identityProviderId (Optional) The Id of the identity provider. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the identity provider.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createIdentityProvider: function(identityProviderId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider')
          .urlSegment(identityProviderId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a tenant. You can optionally specify an Id for the tenant, if not provided one will be generated.
   *
   * @param {?string} tenantId (Optional) The Id for the tenant. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the tenant.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createTenant: function(tenantId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/tenant')
          .urlSegment(tenantId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a user. You can optionally specify an Id for the user, if not provided one will be generated.
   *
   * @param {?string} userId (Optional) The Id for the user. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the user.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createUser: function(userId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a user action. This action cannot be taken on a user until this call successfully returns. Anytime after
   * that the user action can be applied to any user.
   *
   * @param {?string} userActionId (Optional) The Id for the user action. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the user action.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createUserAction: function(userActionId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a user reason. This user action reason cannot be used when actioning a user until this call completes
   * successfully. Anytime after that the user action reason can be used.
   *
   * @param {?string} userActionReasonId (Optional) The Id for the user action reason. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the user action reason.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createUserActionReason: function(userActionReasonId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action-reason')
          .urlSegment(userActionReasonId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a webhook. You can optionally specify an Id for the webhook, if not provided one will be generated.
   *
   * @param {?string} webhookId (Optional) The Id for the webhook. If not provided a secure random UUID will be generated.
   * @param {Object} request The request object that contains all of the information used to create the webhook.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  createWebhook: function(webhookId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/webhook')
          .urlSegment(webhookId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deactivates the application with the given Id.
   *
   * @param {string} applicationId The Id of the application to deactivate.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deactivateApplication: function(applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deactivates the user with the given Id.
   *
   * @param {string} userId The Id of the user to deactivate.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deactivateUser: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deactivates the user action with the given Id.
   *
   * @param {string} userActionId The Id of the user action to deactivate.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deactivateUserAction: function(userActionId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deactivates the users with the given ids.
   *
   * @param {Array} userIds The ids of the users to deactivate.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deactivateUsers: function(userIds) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/bulk')
          .urlParameter('userId', userIds)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Hard deletes an application. This is a dangerous operation and should not be used in most circumstances. This will
   * delete the application, any registrations for that application, metrics and reports for the application, all the
   * roles for the application, and any other data associated with the application. This operation could take a very
   * long time, depending on the amount of data in your database.
   *
   * @param {string} applicationId The Id of the application to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteApplication: function(applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlParameter('hardDelete', true)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Hard deletes an application role. This is a dangerous operation and should not be used in most circumstances. This
   * permanently removes the given role from all users that had it.
   *
   * @param {string} applicationId The Id of the application to deactivate.
   * @param {string} roleId The Id of the role to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteApplicationRole: function(applicationId, roleId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlSegment("role")
          .urlSegment(roleId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the email template for the given Id.
   *
   * @param {string} emailTemplateId The Id of the email template to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteEmailTemplate: function(emailTemplateId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template')
          .urlSegment(emailTemplateId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the group for the given Id.
   *
   * @param {string} groupId The Id of the group to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteGroup: function(groupId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group')
          .urlSegment(groupId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Removes users as members of a group.
   *
   * @param {Object} request The member request that contains all of the information used to remove members to the group.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteGroupMembers: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group/member')
          .setJSONBody(request)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the identity provider for the given Id.
   *
   * @param {string} identityProviderId The Id of the identity provider to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteIdentityProvider: function(identityProviderId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider')
          .urlSegment(identityProviderId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the user registration for the given user and application.
   *
   * @param {string} userId The Id of the user whose registration is being deleted.
   * @param {string} applicationId The Id of the application to remove the registration for.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteRegistration: function(userId, applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/registration')
          .urlSegment(userId)
          .urlSegment(applicationId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the tenant for the given Id.
   *
   * @param {string} tenantId The Id of the tenant to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteTenant: function(tenantId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/tenant')
          .urlSegment(tenantId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the user for the given Id. This permanently deletes all information, metrics, reports and data associated
   * with the user.
   *
   * @param {string} userId The Id of the user to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteUser: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .urlParameter('hardDelete', true)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the user action for the given Id. This permanently deletes the user action and also any history and logs of
   * the action being applied to any users.
   *
   * @param {string} userActionId The Id of the user action to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteUserAction: function(userActionId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .urlParameter('hardDelete', true)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the user action reason for the given Id.
   *
   * @param {string} userActionReasonId The Id of the user action reason to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteUserActionReason: function(userActionReasonId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action-reason')
          .urlSegment(userActionReasonId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the users with the given ids.
   *
   * @param {Object} request The ids of the users to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteUsers: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/bulk')
          .setJSONBody(request)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Deletes the webhook for the given Id.
   *
   * @param {string} webhookId The Id of the webhook to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  deleteWebhook: function(webhookId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/webhook')
          .urlSegment(webhookId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Disable Two Factor authentication for a user.
   *
   * @param {string} userId The Id of the User for which you're disabling Two Factor authentication.
   * @param {string} code The Two Factor code used verify the the caller knows the Two Factor secret.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  disableTwoFactor: function(userId, code) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/two-factor')
          .urlParameter('userId', userId)
          .urlParameter('code', code)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Enable Two Factor authentication for a user.
   *
   * @param {string} userId The Id of the user to enable Two Factor authentication.
   * @param {Object} request The two factor enable request information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  enableTwoFactor: function(userId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/two-factor')
          .urlSegment(userId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Exchange a refresh token for a new JWT.
   *
   * @param {Object} request The refresh request.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  exchangeRefreshTokenForJWT: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/refresh')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Begins the forgot password sequence, which kicks off an email to the user so that they can reset their password.
   *
   * @param {Object} request The request that contains the information about the user so that they can be emailed.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  forgotPassword: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/forgot-password')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Generate a new Email Verification Id to be used with the Verify Email API. This API will not attempt to send an
   * email to the User. This API may be used to collect the verificationId for use with a third party system.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  generateEmailVerificationId: function(email) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-email')
          .urlParameter('email', email)
          .urlParameter('sendVerifyPasswordEmail', false)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Generate a new Application Registration Verification Id to be used with the Verify Registration API. This API will not attempt to send an
   * email to the User. This API may be used to collect the verificationId for use with a third party system.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @param {string} applicationId The Id of the application to be verified.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  generateRegistrationVerificationId: function(email, applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-registration')
          .urlParameter('email', email)
          .urlParameter('sendVerifyPasswordEmail', false)
          .urlParameter('applicationId', applicationId)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Generate a Two Factor secret that can be used to enable Two Factor authentication for a User. The response will contain
   * both the secret and a Base32 encoded form of the secret which can be shown to a User when using a 2 Step Authentication
   * application such as Google Authenticator.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  generateTwoFactorSecret: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/two-factor/secret')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Generate a Two Factor secret that can be used to enable Two Factor authentication for a User. The response will contain
   * both the secret and a Base32 encoded form of the secret which can be shown to a User when using a 2 Step Authentication
   * application such as Google Authenticator.
   *
   * @param {string} encodedJWT The encoded JWT (access token).
   * @return {Promise} A Promise for the FusionAuth call.
   */
  generateTwoFactorSecretUsingJWT: function(encodedJWT) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/two-factor/secret')
          .authorization('JWT ' + encodedJWT)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Bulk imports multiple users. This does some validation, but then tries to run batch inserts of users. This reduces
   * latency when inserting lots of users. Therefore, the error response might contain some information about failures,
   * but it will likely be pretty generic.
   *
   * @param {Object} request The request that contains all of the information about all of the users to import.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  importUsers: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/import')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Issue a new access token (JWT) for the requested Application after ensuring the provided JWT is valid. A valid
   * access token is properly signed and not expired.
   * <p>
   * This API may be used in an SSO configuration to issue new tokens for another application after the user has
   * obtained a valid token from authentication.
   *
   * @param {string} applicationId The Application Id for which you are requesting a new access token be issued.
   * @param {string} encodedJWT The encoded JWT (access token).
   * @return {Promise} A Promise for the FusionAuth call.
   */
  issueJWT: function(applicationId, encodedJWT) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/issue')
          .authorization('JWT ' + encodedJWT)
          .urlParameter('applicationId', applicationId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Logs a user in.
   *
   * @param {Object} request The login request that contains the user credentials used to log them in.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  login: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/login')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Sends a ping to FusionAuth indicating that the user was automatically logged into an application. When using
   * FusionAuth's SSO or your own, you should call this if the user is already logged in centrally, but accesses an
   * application where they no longer have a session. This helps correctly track login counts, times and helps with
   * reporting.
   *
   * @param {string} userId The Id of the user that was logged in.
   * @param {string} applicationId The Id of the application that they logged into.
   * @param {?string} callerIPAddress (Optional) The IP address of the end-user that is logging in. If a null value is provided
   *    the IP address will be that of the client or last proxy that sent the request.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  loginPing: function(userId, applicationId, callerIPAddress) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/login')
          .urlSegment(userId)
          .urlSegment(applicationId)
          .urlParameter('ipAddress', callerIPAddress)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * The Logout API is intended to be used to remove the refresh token and access token cookies if they exist on the
   * client and revoke the refresh token stored. This API does nothing if the request does not contain an access
   * token or refresh token cookies.
   *
   * @param {Object} global When this value is set to true all of the refresh tokens issued to the owner of the
   *    provided token will be revoked.
   * @param {?string} refreshToken (Optional) The refresh_token as a request parameter instead of coming in via a cookie.
   *    If provided this takes precedence over the cookie.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  logout: function(global, refreshToken) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/logout')
          .urlParameter('global', global)
          .urlParameter('refreshToken', refreshToken)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the identity provider for the given domain. A 200 response code indicates the domain is managed
   * by a registered identity provider. A 404 indicates the domain is not managed.
   *
   * @param {string} domain The domain or email address to lookup.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  lookupIdentityProvider: function(domain) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider/lookup')
          .urlParameter('domain', domain)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Modifies a temporal user action by changing the expiration of the action and optionally adding a comment to the
   * action.
   *
   * @param {string} actionId The Id of the action to modify. This is technically the user action log id.
   * @param {Object} request The request that contains all of the information about the modification.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  modifyAction: function(actionId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlSegment(actionId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Reactivates the application with the given Id.
   *
   * @param {string} applicationId The Id of the application to reactivate.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  reactivateApplication: function(applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlParameter('reactivate', true)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Reactivates the user with the given Id.
   *
   * @param {string} userId The Id of the user to reactivate.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  reactivateUser: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .urlParameter('reactivate', true)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Reactivates the user action with the given Id.
   *
   * @param {string} userActionId The Id of the user action to reactivate.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  reactivateUserAction: function(userActionId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .urlParameter('reactivate', true)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Reconcile a User to FusionAuth using JWT issued from another Identity Provider.
   *
   * @param {Object} request The reconcile request that contains the data to reconcile the User.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  reconcileJWT: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/reconcile')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Registers a user for an application. If you provide the User and the UserRegistration object on this request, it
   * will create the user as well as register them for the application. This is called a Full Registration. However, if
   * you only provide the UserRegistration object, then the user must already exist and they will be registered for the
   * application. The user id can also be provided and it will either be used to look up an existing user or it will be
   * used for the newly created User.
   *
   * @param {?string} userId (Optional) The Id of the user being registered for the application and optionally created.
   * @param {Object} request The request that optionally contains the User and must contain the UserRegistration.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  register: function(userId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/registration')
          .urlSegment(userId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Re-sends the verification email to the user.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  resendEmailVerification: function(email) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-email')
          .urlParameter('email', email)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Re-sends the application registration verification email to the user.
   *
   * @param {string} email The email address of the user that needs a new verification email.
   * @param {string} applicationId The Id of the application to be verified.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  resendRegistrationVerification: function(email, applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-registration')
          .urlParameter('email', email)
          .urlParameter('applicationId', applicationId)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves a single action log (the log of a user action that was taken on a user previously) for the given Id.
   *
   * @param {string} actionId The Id of the action to retrieve.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveAction: function(actionId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlSegment(actionId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the actions for the user with the given Id.
   *
   * @param {string} userId The Id of the user to fetch the actions for.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveActions: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/action')
          .urlParameter('userId', userId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the application for the given id or all of the applications if the id is null.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveApplication: function(applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the applications.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveApplications: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves a single audit log for the given Id.
   *
   * @param {string} auditLogId The Id of the audit log to retrieve.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveAuditLog: function(auditLogId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system/audit-log')
          .urlSegment(auditLogId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the daily active user report between the two instants. If you specify an application id, it will only
   * return the daily active counts for that application.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @param {Object} start The start instant as UTC milliseconds since Epoch.
   * @param {Object} end The end instant as UTC milliseconds since Epoch.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveDailyActiveReport: function(applicationId, start, end) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/daily-active-user')
          .urlParameter('applicationId', applicationId)
          .urlParameter('start', start)
          .urlParameter('end', end)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the email template for the given Id. If you don't specify the id, this will return all of the email templates.
   *
   * @param {?string} emailTemplateId (Optional) The Id of the email template.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveEmailTemplate: function(emailTemplateId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template')
          .urlSegment(emailTemplateId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Creates a preview of the email template provided in the request. This allows you to preview an email template that
   * hasn't been saved to the database yet. The entire email template does not need to be provided on the request. This
   * will create the preview based on whatever is given.
   *
   * @param {Object} request The request that contains the email template and optionally a locale to render it in.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveEmailTemplatePreview: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template/preview')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the email templates.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveEmailTemplates: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the group for the given Id.
   *
   * @param {string} groupId The Id of the group.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveGroup: function(groupId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group')
          .urlSegment(groupId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the groups.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveGroups: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the identity provider for the given id or all of the identity providers if the id is null.
   *
   * @param {?string} identityProviderId (Optional) The identity provider id.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveIdentityProvider: function(identityProviderId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider')
          .urlSegment(identityProviderId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the identity providers.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveIdentityProviders: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the applications that are currently inactive.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveInactiveApplications: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlParameter('inactive', true)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the user actions that are currently inactive.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveInactiveUserActions: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlParameter('inactive', true)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the available integrations.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveIntegration: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/integration')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the Public Key configured for verifying JSON Web Tokens (JWT) by the key Id. If the key Id is provided a
   * single public key will be returned if one is found by that id. If the optional parameter key Id is not provided all
   * public keys will be returned.
   *
   * @param {?string} keyId (Optional) The Id of the public key.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveJWTPublicKey: function(keyId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/public-key')
          .urlSegment(keyId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all Public Keys configured for verifying JSON Web Tokens (JWT).
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveJWTPublicKeys: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/public-key')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the login report between the two instants. If you specify an application id, it will only return the
   * login counts for that application.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @param {Object} start The start instant as UTC milliseconds since Epoch.
   * @param {Object} end The end instant as UTC milliseconds since Epoch.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveLoginReport: function(applicationId, start, end) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/login')
          .urlParameter('applicationId', applicationId)
          .urlParameter('start', start)
          .urlParameter('end', end)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the monthly active user report between the two instants. If you specify an application id, it will only
   * return the monthly active counts for that application.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @param {Object} start The start instant as UTC milliseconds since Epoch.
   * @param {Object} end The end instant as UTC milliseconds since Epoch.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveMonthlyActiveReport: function(applicationId, start, end) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/monthly-active-user')
          .urlParameter('applicationId', applicationId)
          .urlParameter('start', start)
          .urlParameter('end', end)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the Oauth2 configuration for the application for the given Application Id.
   *
   * @param {string} applicationId The Id of the Application to retrieve OAuth configuration.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveOauthConfiguration: function(applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlSegment("oauth-configuration")
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the password validation rules.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrievePasswordValidationRules: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system-configuration/password-validation-rules')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the refresh tokens that belong to the user with the given Id.
   *
   * @param {string} userId The Id of the user.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveRefreshTokens: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/refresh')
          .urlParameter('userId', userId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user registration for the user with the given id and the given application id.
   *
   * @param {string} userId The Id of the user.
   * @param {string} applicationId The Id of the application.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveRegistration: function(userId, applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/registration')
          .urlSegment(userId)
          .urlSegment(applicationId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the registration report between the two instants. If you specify an application id, it will only return
   * the registration counts for that application.
   *
   * @param {?string} applicationId (Optional) The application id.
   * @param {Object} start The start instant as UTC milliseconds since Epoch.
   * @param {Object} end The end instant as UTC milliseconds since Epoch.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveRegistrationReport: function(applicationId, start, end) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/registration')
          .urlParameter('applicationId', applicationId)
          .urlParameter('start', start)
          .urlParameter('end', end)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the system configuration.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveSystemConfiguration: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system-configuration')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the tenant for the given Id.
   *
   * @param {string} tenantId The Id of the tenant.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveTenant: function(tenantId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/tenant')
          .urlSegment(tenantId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the tenants.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveTenants: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/tenant')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the totals report. This contains all of the total counts for each application and the global registration
   * count.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveTotalReport: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/totals')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user for the given Id.
   *
   * @param {string} userId The Id of the user.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUser: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user action for the given Id. If you pass in null for the id, this will return all of the user
   * actions.
   *
   * @param {?string} userActionId (Optional) The Id of the user action.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserAction: function(userActionId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user action reason for the given Id. If you pass in null for the id, this will return all of the user
   * action reasons.
   *
   * @param {?string} userActionReasonId (Optional) The Id of the user action reason.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserActionReason: function(userActionReasonId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action-reason')
          .urlSegment(userActionReasonId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all the user action reasons.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserActionReasons: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action-reason')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the user actions.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserActions: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user by a change password Id. The intended use of this API is to retrieve a user after the forgot
   * password workflow has been initiated and you may not know the user's email or username.
   *
   * @param {string} changePasswordId The unique change password Id that was sent via email or returned by the Forgot Password API.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserByChangePasswordId: function(changePasswordId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlParameter('changePasswordId', changePasswordId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user for the given email.
   *
   * @param {string} email The email of the user.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserByEmail: function(email) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlParameter('email', email)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user for the loginId. The loginId can be either the username or the email.
   *
   * @param {string} loginId The email or username of the user.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserByLoginId: function(loginId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlParameter('loginId', loginId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user for the given username.
   *
   * @param {string} username The username of the user.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserByUsername: function(username) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlParameter('username', username)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user by a verificationId. The intended use of this API is to retrieve a user after the forgot
   * password workflow has been initiated and you may not know the user's email or username.
   *
   * @param {string} verificationId The unique verification Id that has been set on the user object.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserByVerificationId: function(verificationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlParameter('verificationId', verificationId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all of the comments for the user with the given Id.
   *
   * @param {string} userId The Id of the user.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserComments: function(userId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/comment')
          .urlSegment(userId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the last number of login records for a user.
   *
   * @param {string} userId The Id of the user.
   * @param {Object} offset The initial record. e.g. 0 is the last login, 100 will be the 100th most recent login.
   * @param {string} limit (Optional, defaults to 10) The number of records to retrieve.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserLoginReport: function(userId, offset, limit) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/report/user-login')
          .urlParameter('userId', userId)
          .urlParameter('offset', offset)
          .urlParameter('limit', limit)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the user for the given Id. This method does not use an API key, instead it uses a JSON Web Token (JWT) for authentication.
   *
   * @param {string} encodedJWT The encoded JWT (access token).
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveUserUsingJWT: function(encodedJWT) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .authorization('JWT ' + encodedJWT)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the webhook for the given Id. If you pass in null for the id, this will return all the webhooks.
   *
   * @param {?string} webhookId (Optional) The Id of the webhook.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveWebhook: function(webhookId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/webhook')
          .urlSegment(webhookId)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves all the webhooks.
   *
   * @return {Promise} A Promise for the FusionAuth call.
   */
  retrieveWebhooks: function() {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/webhook')
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Revokes a single refresh token, all tokens for a user or all tokens for an application. If you provide a user id
   * and an application id, this will delete all the refresh tokens for that user for that application.
   *
   * @param {?string} token (Optional) The refresh token to delete.
   * @param {?string} userId (Optional) The user id whose tokens to delete.
   * @param {?string} applicationId (Optional) The application id of the tokens to delete.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  revokeRefreshToken: function(token, userId, applicationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/refresh')
          .urlParameter('token', token)
          .urlParameter('userId', userId)
          .urlParameter('applicationId', applicationId)
          .delete()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Searches the audit logs with the specified criteria and pagination.
   *
   * @param {Object} request The search criteria and pagination information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  searchAuditLogs: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system/audit-log/search')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the users for the given ids. If any id is invalid, it is ignored.
   *
   * @param {Array} ids The user ids to search for.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  searchUsers: function(ids) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/search')
          .urlParameter('ids', ids)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Retrieves the users for the given search criteria and pagination.
   *
   * @param {Object} request The search criteria and pagination constraints. Fields used: queryString, numberOfResults, startRow,
   *    and sort fields.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  searchUsersByQueryString: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/search')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Send an email using an email template id. You can optionally provide <code>requestData</code> to access key value
   * pairs in the email template.
   *
   * @param {string} emailTemplateId The id for the template.
   * @param {Object} request The send email request that contains all of the information used to send the email.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  sendEmail: function(emailTemplateId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/send')
          .urlSegment(emailTemplateId)
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Send a Two Factor authentication code to assist in setting up Two Factor authentication or disabling.
   *
   * @param {Object} request The request object that contains all of the information used to send the code.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  sendTwoFactorCode: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/two-factor/send')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Send a Two Factor authentication code to allow the completion of Two Factor authentication.
   *
   * @param {string} twoFactorId The Id returned by the Login API necessary to complete Two Factor authentication.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  sendTwoFactorCodeForLogin: function(twoFactorId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/two-factor/send')
          .urlSegment(twoFactorId)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Complete login using a 2FA challenge
   *
   * @param {Object} request The login request that contains the user credentials used to log them in.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  twoFactorLogin: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/two-factor/login')
          .setJSONBody(request)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the application with the given Id.
   *
   * @param {string} applicationId The Id of the application to update.
   * @param {Object} request The request that contains all of the new application information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateApplication: function(applicationId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the application role with the given id for the application.
   *
   * @param {string} applicationId The Id of the application that the role belongs to.
   * @param {string} roleId The Id of the role to update.
   * @param {Object} request The request that contains all of the new role information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateApplicationRole: function(applicationId, roleId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/application')
          .urlSegment(applicationId)
          .urlSegment("role")
          .urlSegment(roleId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the email template with the given Id.
   *
   * @param {string} emailTemplateId The Id of the email template to update.
   * @param {Object} request The request that contains all of the new email template information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateEmailTemplate: function(emailTemplateId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/email/template')
          .urlSegment(emailTemplateId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the group with the given Id.
   *
   * @param {string} groupId The Id of the group to update.
   * @param {Object} request The request that contains all of the new group information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateGroup: function(groupId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/group')
          .urlSegment(groupId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the identity provider with the given Id.
   *
   * @param {string} identityProviderId The Id of the identity provider to update.
   * @param {Object} request The request object that contains the updated identity provider.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateIdentityProvider: function(identityProviderId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/identity-provider')
          .urlSegment(identityProviderId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the available integrations.
   *
   * @param {Object} request The request that contains all of the new integration information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateIntegrations: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/integration')
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the registration for the user with the given id and the application defined in the request.
   *
   * @param {string} userId The Id of the user whose registration is going to be updated.
   * @param {Object} request The request that contains all of the new registration information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateRegistration: function(userId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/registration')
          .urlSegment(userId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the system configuration.
   *
   * @param {Object} request The request that contains all of the new system configuration information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateSystemConfiguration: function(request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/system-configuration')
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the tenant with the given Id.
   *
   * @param {string} tenantId The Id of the tenant to update.
   * @param {Object} request The request that contains all of the new tenant information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateTenant: function(tenantId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/tenant')
          .urlSegment(tenantId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the user with the given Id.
   *
   * @param {string} userId The Id of the user to update.
   * @param {Object} request The request that contains all of the new user information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateUser: function(userId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user')
          .urlSegment(userId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the user action with the given Id.
   *
   * @param {string} userActionId The Id of the user action to update.
   * @param {Object} request The request that contains all of the new user action information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateUserAction: function(userActionId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action')
          .urlSegment(userActionId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the user action reason with the given Id.
   *
   * @param {string} userActionReasonId The Id of the user action reason to update.
   * @param {Object} request The request that contains all of the new user action reason information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateUserActionReason: function(userActionReasonId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user-action-reason')
          .urlSegment(userActionReasonId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Updates the webhook with the given Id.
   *
   * @param {string} webhookId The Id of the webhook to update.
   * @param {Object} request The request that contains all of the new webhook information.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  updateWebhook: function(webhookId, request) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/webhook')
          .urlSegment(webhookId)
          .setJSONBody(request)
          .put()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Validates the provided JWT (encoded JWT string) to ensure the token is valid. A valid access token is properly
   * signed and not expired.
   * <p>
   * This API may be used to verify the JWT as well as decode the encoded JWT into human readable identity claims.
   *
   * @param {string} encodedJWT The encoded JWT (access token).
   * @return {Promise} A Promise for the FusionAuth call.
   */
  validateJWT: function(encodedJWT) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/jwt/validate')
          .authorization('JWT ' + encodedJWT)
          .get()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Confirms a email verification. The Id given is usually from an email sent to the user.
   *
   * @param {string} verificationId The email verification id sent to the user.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  verifyEmail: function(verificationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-email')
          .urlSegment(verificationId)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /**
   * Confirms an application registration. The Id given is usually from an email sent to the user.
   *
   * @param {string} verificationId The registration verification Id sent to the user.
   * @return {Promise} A Promise for the FusionAuth call.
   */
  verifyRegistration: function(verificationId) {
    return new Promise((resolve, reject) => {
      this._start()
          .uri('/api/user/verify-registration')
          .urlSegment(verificationId)
          .post()
          .go(this._responseHandler(resolve, reject));
    });
  },

  /* ===================================================================================================================
   * Private methods
   * ===================================================================================================================*/

  /**
   * Require a parameter to be defined, if null or un-defined this throws an exception.
   * @param {Object} value The value that must be defined.
   * @param {string} name The name of the parameter.
   * @private
   */
  _requireNonNull: function(value, name) {
    if (typeof value === 'undefined' || value === null) {
      throw new Error(name + ' parameter is required.');
    }
  },

  /**
   * Returns a function to handle the promises for each call.
   *
   * @param resolve The promise's resolve function.
   * @param reject The promise's reject function.
   * @returns {Function} The function that will call either the resolve or reject functions based on the ClientResponse.
   * @private
   */
  _responseHandler: function(resolve, reject) {
    return function(response) {
      if (response.wasSuccessful()) {
        resolve(response);
      } else {
        reject(response);
      }
    };
  },

  /**
   * creates a rest client
   *
   * @returns {RESTClient} The RESTClient that will be used to call.
   * @private
   */
  _start: function() {
    return new RESTClient().authorization(this.apiKey).setUrl(this.host);
  }
};

module.exports = FusionAuthClient;